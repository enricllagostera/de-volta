<!DOCTYPE html>
<html>
  <head>
    <title>My Custom Template (with Beholder integration)</title>
    <meta charset="UTF-8" />
  </head>
  <body onkeyup="kbTest(event)">
    <canvas id="canvas"></canvas>
    <div id="beholder-root"></div>
    <script src="index.js"></script>
    <script>
      var engine = new Engine({"args":[],"canvasResizePolicy":2,"executable":"index","experimentalVK":false,"fileSizes":{"index.pck":732896,"index.wasm":17493574},"focusCanvas":true,"gdnativeLibs":[]});
      engine.startGame();
    </script>
    <script
      src="https://unpkg.com/beholder-detection@1.3.1/dist/beholder-detection.js"
      crossorigin
    ></script>
    <script>
        const Beholder = window['beholder-detection'].default;
      let beholderConfig = {
        camera_params: {
          videoSize: 1, // The video size values map to the following [320 x 240, 640 x 480, 1280 x 720, 1920 x 1080]
          rearCamera: true, // Boolean value for defaulting to the rear facing camera. Only works on mobile
          torch: true, // Boolean value for if torch/flashlight is on. Only works for rear facing mobile cameras. Can only be set from init
        },
        detection_params: {
          minMarkerDistance: 2,
          minMarkerPerimeter: 0.01,
          maxMarkerPerimeter: 1,
          sizeAfterPerspectiveRemoval: 49,
          area: {
            start: { x: 0.35, y: 0.16 },
            end:   { x: 1, y: 0.85 },
          },
        },
        feed_params: {
          contrast: 0,
          brightness: 0,
          grayscale: 0,
          flip: false,
        },
        overlay_params: {
          present: true, // Determines if the Beholder overlay will display or be invisible entirely via display: none
          hide: true, // Determines if the overlay should be hidden on the left of the screen or visible
        },
      };
      Beholder.init("#beholder-root", beholderConfig);

      /*
      LIST OF COMMANDS

      Example:
      spaceHopper.sendCommand("activate_insert", "empty");

      "activate_insert" : "empty", "launching", "navigating", "repairing"

      // LAUNCHING
      "set_aiming" : "left", "right" // physical crank
      "set_power" : "0..100" // throttle or slider
      "set_engage"  // momentary, either key or protective case and switch

      ~~ Deprecated - FLYING
      ~~ "set_shield" : "true", "false" // toggle
      ~~ "set_boost" // momentary, flip switch

      // NAVIGATION
      "set_scope" : "x, "y" // continuous, every once in a while

      // REPAIRING
      "bolt_incremented" : "left", "right" 
      */

      // Sets up callback refs from the Godot app; Each of these is a function.
      spaceHopper = {};
      let navAnchor, navFocus, repair1, repair2;

      spaceHopper.initCallbacks = function (cb) {
        spaceHopper.sendCommand = cb;
        spaceHopper.sendCommand("activate_insert", "empty");

        navAnchor = Beholder.getMarker(7);
        navAnchor.timeout = 200;
        navFocus = Beholder.getMarker(5);
        navFocus.timeout = 200;
        repair1 = Beholder.getMarker(6);
        repair1.timeout = 200;
        // repair2.rotationSmoothing = 0.1;
        repair2 = Beholder.getMarker(9);
        repair2.timeout = 200;
        // repair2.rotationSmoothing = 0.1;
      };

      function runNavigation() {
        // x 81 - 280
        // y 25 -> -36
        let focusOffset = navFocus.center.clone().sub(navAnchor.center).sub({ x: 81, y: 19 });
        // focusOffset.y *= ;
        focusOffset.y /= 40;
        focusOffset.y += 1;
        focusOffset.x /= 150;
        // console.log(focusOffset.x, focusOffset.y);
        focusOffset.scale(100);
        spaceHopper.sendCommand("set_scope", focusOffset.x, focusOffset.y)
      }

      function runRepair() {
        if (repair1.deltaRotation > 0.12 || repair1.deltaRotation < -0.12) spaceHopper.sendCommand("bolt_incremented", "left");
        // console.log(repair2.deltaRotation);
        if (repair2.deltaRotation > 0.12 || repair2.deltaRotation < -0.12) spaceHopper.sendCommand("bolt_incremented", "right");
      }

      let currentInsert = 'empty';
      function detectInserts() {
        if (currentInsert !== 'navigating') {
          if (navAnchor.present) {
            spaceHopper.sendCommand("activate_insert", "navigating");
            currentInsert = 'navigating';
          }
        }

        if (currentInsert !== 'repairing') {
          if (repair1.present) {
            spaceHopper.sendCommand("activate_insert", "repairing");
            currentInsert = 'repairing';
          }
        }

        if (currentInsert !== 'empty') {
          if (!repair1.present && !navAnchor.present) {
            spaceHopper.sendCommand("activate_insert", "empty");
            currentInsert = 'empty';
          }
        }
      }

      // Called by Godot every frame
      // It is from inside this function that the sendCommand calls can be made
      let prevTime = Date.now();
      const FRAME_RATE = 1000 / 20;
      let frameTimer = FRAME_RATE;
      spaceHopper.gameUpdate = function () {
        let currentTime = Date.now();
        let dt = currentTime - prevTime;
        frameTimer -= dt;
        if (frameTimer > 0) return;

        frameTimer = FRAME_RATE;
        Beholder.update();
        // console.log(currentInsert);

        detectInserts();
        switch(currentInsert) {
          case 'empty': break;
          case 'navigating': runNavigation(); break;
          case 'repairing': runRepair(); break;
        }
      };

      // The game object needs to be added to `window`
      window.spaceHopper = spaceHopper;

      // DEBUG only method. It sends commands on keyup events, for checking 
      // that all commands are well-interpreted in Godot
      function kbTest(event) {
        console.log(event)
        // CHANGING INSERTS
        //"activate_insert" : "empty", "launching", "navigating", "repairing"
        if (event.key == "q") {
          spaceHopper.sendCommand("activate_insert", "empty")
        }
        if (event.key == "w") {
          spaceHopper.sendCommand("activate_insert", "launching")
        }
        if (event.key == "e") {
          spaceHopper.sendCommand("activate_insert", "navigating")
        }
        if (event.key == "r") {
          spaceHopper.sendCommand("activate_insert", "repairing")
        }
        // LAUNCHING
        // "set_aiming" : "left", "right" // physical crank
        // "set_power" : "0..100" // throttle or slider
        // "set_engage"  // momentary, either key or protective case and switch
        if (event.key == "u") {
          spaceHopper.sendCommand("set_aiming", "left")
        }
        if (event.key == "i") {
          spaceHopper.sendCommand("set_aiming", "right")
        }
        if (event.key == "o") {
          // For now it just sends some random value 
          spaceHopper.sendCommand("set_power", random0to100())
        }
        if (event.key == "p") {
          spaceHopper.sendCommand("set_engage")
        }
        /* 
        // NAVIGATION
        "set_scope" : "x, "y" // continuous, every once in a while 
        */
        if (event.key == "j") {
          spaceHopper.sendCommand("set_scope", random0to100(), random0to100())
        }
        /*
        // REPAIRING
        "bolt_incremented" : "left", "right" 
        */
        if (event.key == "k") {
          spaceHopper.sendCommand("bolt_incremented", "left")
        }
        if (event.key == "l") {
          spaceHopper.sendCommand("bolt_incremented", "right")
        }
      };     

      function random0to100(){
        return Math.floor(Math.random()*100);
      }
    </script>
  </body>
</html>

